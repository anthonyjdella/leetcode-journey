# Tips

* If input array is sorted then
    - Binary search
    - Two pointers

* If asked for all permutations/subsets then
    - Backtracking

* If given a tree then
    - DFS
    - BFS

* If given a graph then
    - DFS
    - BFS

* If given a linked list then
    - Two pointers

* If recursion is banned then
    - Stack

* If must solve in-place then
    - Swap corresponding values
    - Store one or more different values in the same pointer

* If asked for maximum/minumum subarray/subset/options then
    - Dynamic programming

* If asked for top/least K items then
    - Heap

* If asked for common strings then
    - Map
    - Trie

* Else
    - Map/Set for O(1) time & O(n) space
    - Sort input for O(nlogn) time and O(1) space

---

## Problems

* Arrays

```
Remove, Search, Range Search, insert position, Rotate, Search in rotated, Max subarray, Set Matrix, Pascalâ€™s Triangle, 2 Sum, 3 Sum, Single number, Intersection, Majority, Duplicates, Missing, Consecutive sequence, valid sudoku, plus one
```


* Sorting
```
Bubble, Insertion, Counting, Quick, Merge
```

* Heap
```
Kth largest in array, Kth smallest in matrix, Median, Ugly Number, Super Ugly Number,
Strings Reverse, First unique char, anagram, pallindrome, last word, common prefix, substring without repeating chars
```

* Numbers
```
Pallindrome, Power, Sqrt, Reverse, Happy number, Guess number, Next permutation, single
```

* Linked Lists
```
Delete, Reverse, Remove, Cycle, Reverse range, Rotate, Partition, Merge, Swap Node, Add, Add one, Remove duplicates, Pallindrome, Odd-even
```

* Binary Trees
```
Max depth, Min depth, Invert, Same, LCA, Level order, Inorder, Preorder, Postorder, Balanced, Symmetric, Validate, Paths, Path sum, Max path sum, Right side view, Flatten to linked list, Kth smallest, Next Right
```

* Graphs
```
Islands
```

* Dynamic Programming
```
Climb Stairs, House Robber, Combination Sum, Palindromic Substring, Max product subarray, Frog Jump, Coin Change, Unique Paths, LIS, minimum path sum
```

## What to do when stuck

Roadmap to solving any question if 100% stuck: 

Recursion -> Linked list -> Stack -> Queue -> Two pointers -> Sliding-window -> hashing -> sorting -> binary search -> trees -> BST -> Heaps -> Graph basics -> BFS -> DFS -> backtracking -> greedy -> Dynamic programming -> advanced graph -> Union find -> bit manipulation.